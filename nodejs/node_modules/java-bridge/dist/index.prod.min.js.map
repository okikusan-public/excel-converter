{"version":3,"file":"index.prod.min.js","mappings":"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","sources":["webpack://java/webpack/universalModuleDefinition","webpack://java/./java.linux-x64-gnu.node","webpack://java/./native.js","webpack://java/./ts-src/definitions.ts","webpack://java/./ts-src/index.ts","webpack://java/./ts-src/java.ts","webpack://java/./ts-src/nativeLib.ts","webpack://java/./ts-src/util.ts","webpack://java/./ts-src/ sync","webpack://java/external node-commonjs \"child_process\"","webpack://java/external node-commonjs \"fs\"","webpack://java/external node-commonjs \"path\"","webpack://java/webpack/bootstrap","webpack://java/webpack/runtime/hasOwnProperty shorthand","webpack://java/webpack/runtime/node module decorator","webpack://java/webpack/runtime/publicPath","webpack://java/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"java\"] = factory();\n\telse\n\t\troot[\"java\"] = factory();\n})(global, () => {\nreturn ","\ntry {\n  process.dlopen(module, require(\"path\").join(__dirname, __webpack_public_path__, \"java.linux-x64-gnu.node\"));\n} catch (error) {\n  throw new Error('node-loader:\\n' + error);\n}\n","/* tslint:disable */\n/* eslint-disable */\n/* prettier-ignore */\n\n/* auto-generated by NAPI-RS */\n\nconst { existsSync, readFileSync } = require('fs')\nconst { join } = require('path')\n\nconst { platform, arch } = process\n\nlet nativeBinding = null\nlet localFileExisted = false\nlet loadError = null\n\nfunction isMusl() {\n  // For Node 10\n  if (!process.report || typeof process.report.getReport !== 'function') {\n    try {\n      const lddPath = require('child_process').execSync('which ldd').toString().trim()\n      return readFileSync(lddPath, 'utf8').includes('musl')\n    } catch (e) {\n      return true\n    }\n  } else {\n    const { glibcVersionRuntime } = process.report.getReport().header\n    return !glibcVersionRuntime\n  }\n}\n\nswitch (platform) {\n  case 'android':\n    switch (arch) {\n      case 'arm64':\n        localFileExisted = existsSync(join(__dirname, 'java.android-arm64.node'))\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.android-arm64.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-android-arm64')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'arm':\n        localFileExisted = existsSync(join(__dirname, 'java.android-arm-eabi.node'))\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.android-arm-eabi.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-android-arm-eabi')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on Android ${arch}`)\n    }\n    break\n  case 'win32':\n    switch (arch) {\n      case 'x64':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.win32-x64-msvc.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.win32-x64-msvc.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-win32-x64-msvc')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'ia32':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.win32-ia32-msvc.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.win32-ia32-msvc.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-win32-ia32-msvc')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'arm64':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.win32-arm64-msvc.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.win32-arm64-msvc.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-win32-arm64-msvc')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on Windows: ${arch}`)\n    }\n    break\n  case 'darwin':\n    localFileExisted = existsSync(join(__dirname, 'java.darwin-universal.node'))\n    try {\n      if (localFileExisted) {\n        nativeBinding = require('./java.darwin-universal.node')\n      } else {\n        nativeBinding = __non_webpack_require__('java-bridge-darwin-universal')\n      }\n      break\n    } catch {}\n    switch (arch) {\n      case 'x64':\n        localFileExisted = existsSync(join(__dirname, 'java.darwin-x64.node'))\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.darwin-x64.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-darwin-x64')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'arm64':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.darwin-arm64.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.darwin-arm64.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-darwin-arm64')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on macOS: ${arch}`)\n    }\n    break\n  case 'freebsd':\n    if (arch !== 'x64') {\n      throw new Error(`Unsupported architecture on FreeBSD: ${arch}`)\n    }\n    localFileExisted = existsSync(join(__dirname, 'java.freebsd-x64.node'))\n    try {\n      if (localFileExisted) {\n        nativeBinding = require('./java.freebsd-x64.node')\n      } else {\n        nativeBinding = __non_webpack_require__('java-bridge-freebsd-x64')\n      }\n    } catch (e) {\n      loadError = e\n    }\n    break\n  case 'linux':\n    switch (arch) {\n      case 'x64':\n        if (isMusl()) {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-x64-musl.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-x64-musl.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-x64-musl')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        } else {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-x64-gnu.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-x64-gnu.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-x64-gnu')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        }\n        break\n      case 'arm64':\n        if (isMusl()) {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-arm64-musl.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-arm64-musl.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-arm64-musl')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        } else {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-arm64-gnu.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-arm64-gnu.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-arm64-gnu')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        }\n        break\n      case 'arm':\n        if (isMusl()) {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-arm-musleabihf.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-arm-musleabihf.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-arm-musleabihf')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        } else {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-arm-gnueabihf.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-arm-gnueabihf.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-arm-gnueabihf')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        }\n        break\n      case 'riscv64':\n        if (isMusl()) {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-riscv64-musl.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-riscv64-musl.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-riscv64-musl')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        } else {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-riscv64-gnu.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-riscv64-gnu.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-riscv64-gnu')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        }\n        break\n      case 's390x':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.linux-s390x-gnu.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.linux-s390x-gnu.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-linux-s390x-gnu')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on Linux: ${arch}`)\n    }\n    break\n  default:\n    throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`)\n}\n\nif (!nativeBinding) {\n  if (loadError) {\n    throw loadError\n  }\n  throw new Error(`Failed to load native binding`)\n}\n\nconst { JavaInterfaceProxy, clearDaemonProxies, Java, clearClassProxies, JavaConfig, StdoutRedirect, getJavaLibPath, logging } = nativeBinding\n\nmodule.exports.JavaInterfaceProxy = JavaInterfaceProxy\nmodule.exports.clearDaemonProxies = clearDaemonProxies\nmodule.exports.Java = Java\nmodule.exports.clearClassProxies = clearClassProxies\nmodule.exports.JavaConfig = JavaConfig\nmodule.exports.StdoutRedirect = StdoutRedirect\nmodule.exports.getJavaLibPath = getJavaLibPath\nmodule.exports.logging = logging\n","import { inspect } from 'util';\n\n/**\n * The supported java versions.\n * Your list of supported versions\n * may differ if you use a different\n * version of the jvm shared library.\n */\nexport enum JavaVersion {\n    /** Java version 1.1 */\n    VER_1_1 = '1.1',\n    /** Java version 1.2 */\n    VER_1_2 = '1.2',\n    /** Java version 1.4 */\n    VER_1_4 = '1.4',\n    /** Java version 1.6 */\n    VER_1_6 = '1.6',\n    /** Java version 1.8 */\n    VER_1_8 = '1.8',\n    /** Java version 9 */\n    VER_9 = '9',\n    /** Java version 10 */\n    VER_10 = '10',\n    /**\n     * Java version 19\n     * @since 2.7.0\n     */\n    VER_19 = '19',\n    /**\n     * Java version 20\n     * @since 2.7.0\n     */\n    VER_20 = '20',\n    /**\n     * Java version 21\n     * @since 2.7.0\n     */\n    VER_21 = '21',\n}\n\nObject.freeze(JavaVersion);\n\n/**\n * Any basic javascript type accepted by this library.\n */\nexport declare type BasicType = string | number | boolean | BigInt | null;\n\n/**\n * Any java type accepted by this library, except arrays.\n */\nexport type BasicOrJavaType =\n    | BasicType\n    | JavaObject\n    | JavaClass\n    | JavaClassType;\n\n/**\n * All types accepted by java\n */\nexport type JavaType = BasicOrJavaType | BasicOrJavaType[];\n\n/**\n * A dummy java object class\n */\nexport abstract class JavaObject {}\n\n/**\n * A java class proxy class.\n * This only exists for temporarily storing\n * the class name and the java instance\n * to create the actual class from using the\n * {@link JavaClassProxy.getClassConstructor()}\n * function.\n */\nexport declare class JavaClassProxy {\n    /**\n     * The class name\n     */\n    public 'class.name': string;\n\n    /**\n     * Get the class's constructor\n     *\n     * @return the java instance proxy constructor\n     */\n    public getClassConstructor<\n        T extends JavaClassType = UnknownJavaClassType,\n    >(): T;\n}\n\nexport type JavaClassType = typeof JavaClass;\nexport type UnknownJavaClassType = typeof UnknownJavaClass;\nexport type JavaClassConstructorType = typeof JavaClassConstructor;\n\n/**\n * @inheritDoc UnknownJavaClass\n */\nexport declare class JavaClassInstance extends UnknownJavaClass {}\n\n/**\n * A java class constructor class\n *\n * @see JavaClass\n */\nexport declare class JavaClassConstructor extends JavaClass {\n    public constructor(...args: BasicOrJavaType[]);\n}\n\n/**\n * A constructor type.\n */\nexport type Constructor<T> = { new (): T };\n\n/**\n * A class to be extended for custom class definitions.\n * This does not allow for any methods to be called if not\n * defined in the class definition.\n *\n * This is also just a definition for creating typescript\n * definitions for java classes. This does not actually\n * create a java class.\n *\n * If you want to create a java class inside of typescript,\n * take a look at this\n * [test helper](https://github.com/MarkusJx/node-java-bridge/blob/main/test/testUtil.ts#L65).\n * For implementing interfaces, take a look at the\n * {@link newProxy} function.\n *\n * ## Example\n * ```ts\n * import { importClass } from 'java-bridge';\n *\n * declare class PersonClass extends JavaClass {\n *     public constructor(name: string, age: number);\n *     public newInstanceAsync(name: string, age: number): Promise<Person>;\n *\n *     public getName(): Promise<string>;\n *     public getNameSync(): string;\n *     public getAge(): Promise<number>;\n *     public getAgeSync(): number;\n * }\n *\n * class Person extends importClass<typeof PersonClass>('com.test.Person') {}\n *\n * const person = new Person('John', 20);\n * console.log(person.getNameSync()); // John\n * console.log(person.getAgeSync()); // 20\n * ```\n */\nexport declare class JavaClass extends JavaObject {\n    /**\n     * Get the java class instance\n     */\n    public static get class(): UnknownJavaClass;\n\n    /**\n     * The class proxy class instance\n     */\n    public static readonly 'class.proxy': JavaClassProxy;\n\n    /**\n     * Check if this is an instance of another class.\n     * Pass either the name of the other class or the class itself\n     * to check if this is an instance of it.\n     * Does not overwrite any existing instanceof operator.\n     * This uses the native java instanceof operator.\n     *\n     * This method's name is not affected by the {@link JavaConfig#syncSuffix}\n     * and {@link JavaConfig#asyncSuffix} options.\n     *\n     * ## Example\n     * ```ts\n     * import { importClass } from 'java-bridge';\n     *\n     * const JavaString = importClass('java.lang.String');\n     * const str = new JavaString('Hello World');\n     *\n     * str.instanceOf(JavaString); // true\n     * str.instanceOf('java.lang.String'); // true\n     * str.instanceOf('java.lang.Object'); // true\n     * str.instanceOf('java.lang.Integer'); // false\n     * ```\n     *\n     * @param other the class to check if this is an instance of\n     * @return true if this is instance of `other`\n     */\n    public instanceOf<T extends object>(other: string | T): boolean;\n\n    /**\n     * Default java equals implementation.\n     * Async call.\n     *\n     * @param o the object to compare this to\n     * @returns true if this matches o\n     */\n    public equals(o: JavaClass): Promise<boolean>;\n\n    /**\n     * Default java equals implementation.\n     * Sync call.\n     *\n     * @param o the object to compare this to\n     * @returns true if this matches o\n     */\n    public equalsSync(o: JavaClass): boolean;\n\n    /**\n     * Java default toString method.\n     * Sync call.\n     *\n     * This method's name is not affected by the {@link JavaConfig#syncSuffix}\n     * and {@link JavaConfig#asyncSuffix} options.\n     *\n     * @returns this as a string\n     */\n    public toString(): string;\n\n    /**\n     * Java default toString method.\n     * Sync call.\n     *\n     * This method's name is not affected by the {@link JavaConfig#syncSuffix}\n     * and {@link JavaConfig#asyncSuffix} options.\n     *\n     * @deprecated use {@link toString} instead\n     * @returns this as a string\n     */\n    public toStringSync(): string;\n\n    /**\n     * Java default toString method.\n     * Async call.\n     *\n     * This method's name is not affected by the {@link JavaConfig#syncSuffix}\n     * and {@link JavaConfig#asyncSuffix} options.\n     *\n     * @since 2.4.0\n     * @returns this as a string\n     */\n    public toStringAsync(): Promise<string>;\n\n    /**\n     * Java default hashCode method.\n     * Async call.\n     */\n    public hashCode(): Promise<number>;\n\n    /**\n     * Java default hashCode method.\n     * Sync call.\n     */\n    public hashCodeSync(): number;\n\n    /**\n     * Custom inspect method for an improved console.log output.\n     * This will return the output of {@link toString}.\n     * Will only be defined if {@link JavaConfig.customInspect} is true.\n     *\n     * @since 2.4.0\n     * @returns this as a string\n     */\n    public [inspect.custom]?(): string;\n}\n\n/**\n * The java instance proxy class.\n * This class actually does all the magic.\n * After it is created, this will just be a constructor\n * with all static methods and properties (the accessible ones)\n * stored in it and ready for use. Once the actual instance\n * using the new operator is created, a new\n * java_instance_proxy instance is created, containing\n * the actual java instance (that thing isn't visible though)\n * and all (visible) non-static class member methods and properties.\n */\nexport declare class UnknownJavaClass extends JavaClass {\n    /**\n     * Create a new java class instance.\n     * Async version.\n     *\n     * This method's name is not affected by the {@link JavaConfig#syncSuffix}\n     * and {@link JavaConfig#asyncSuffix} options.\n     *\n     * @template T the type of this class as a new instance of this class will be returned\n     * @param args the arguments to create the instance\n     * @return the java_instance_proxy instance\n     */\n    public static newInstanceAsync(\n        this: never,\n        ...args: BasicOrJavaType[]\n    ): Promise<unknown>;\n    public static newInstanceAsync<T extends JavaClass>(\n        this: Constructor<T>,\n        ...args: BasicOrJavaType[]\n    ): Promise<T>;\n\n    /**\n     * Create a new java instance of type\n     * java_instance_proxy[\"class.proxy.instance\"]\n     *\n     * @param args the arguments to create the instance\n     */\n    public constructor(...args: BasicOrJavaType[]);\n\n    /**\n     * Any class member imported.\n     * We'll need to use 'any' as any is callable.\n     * The actual type would be JavaType | ((...args: JavaType[]) => JavaType | Promise<JavaType>).\n     * Just throwing it out there.\n     */\n    [member: string]: any;\n\n    /**\n     * Any static class member imported.\n     * We'll need to use `any` as `any` is callable.\n     * The actual type would be JavaType | ((...args: JavaType[]) => JavaType | Promise<JavaType>)\n     */\n    static [member: string]: any;\n}\n\n/**\n * An error thrown from the java process.\n * This error may contain the java throwable\n * that caused this error. The cause is only\n * available in synchronous calls.\n */\nexport declare class JavaError extends Error {\n    /**\n     * The throwable that caused this error.\n     * This is only available in synchronous calls or\n     * if the {@link JavaConfig.asyncJavaExceptionObjects} option is true.\n     */\n    public readonly cause?: JavaThrowable;\n}\n\n/**\n * A definition for the java throwable class.\n * @see https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html\n */\nexport declare class JavaThrowable extends UnknownJavaClass {\n    public addSuppressedSync(suppressed: JavaThrowable): void;\n\n    public addSuppressed(suppressed: JavaThrowable): Promise<void>;\n\n    public fillInStackTraceSync(): void;\n\n    public fillInStackTrace(): Promise<void>;\n\n    public getCauseSync(): JavaThrowable;\n\n    public getCause(): Promise<JavaThrowable>;\n\n    public getMessageSync(): string;\n\n    public getMessage(): Promise<string>;\n\n    public getLocalizedMessageSync(): string;\n\n    public getLocalizedMessage(): Promise<string>;\n\n    public getStackTraceSync(): UnknownJavaClass[];\n\n    public getStackTrace(): Promise<UnknownJavaClass[]>;\n\n    public getSuppressedSync(): JavaThrowable[];\n\n    public getSuppressed(): Promise<JavaThrowable[]>;\n\n    public initCauseSync(cause: JavaThrowable): JavaThrowable;\n\n    public initCause(cause: JavaThrowable): Promise<JavaThrowable>;\n\n    public printStackTraceSync(): void;\n\n    public printStackTrace(): Promise<void>;\n\n    public printStackTraceSync(out: JavaObject): void;\n\n    public printStackTrace(out: JavaObject): Promise<void>;\n\n    public setStackTraceSync(stackTrace: UnknownJavaClass[]): void;\n\n    public setStackTrace(stackTrace: UnknownJavaClass[]): Promise<void>;\n}\n","export {\n    JavaVersion,\n    JavaObject,\n    JavaClassInstance,\n    JavaClassProxy,\n    JavaClass,\n    JavaClassConstructor,\n    UnknownJavaClass,\n    JavaType,\n    BasicOrJavaType,\n    BasicType,\n    JavaClassType,\n    Constructor,\n    UnknownJavaClassType,\n    JavaClassConstructorType,\n    JavaError,\n    JavaThrowable,\n} from './definitions';\nimport type * as internal from '../native';\n/**\n * A namespace containing any internal type definitions.\n * Do not actually use anything from this namespace\n * as it only exports types.\n */\nexport type { internal };\nexport * from './java';\nimport * as java from './java';\n\nexport default java;\nexport { getJavaLibPath, InterfaceProxyOptions } from '../native';\nexport { getJavaVersion, getJavaVersionSync } from './util';\nexport type { JavaConfig } from '../native';\n","import {\n    InterfaceProxyOptions,\n    Java,\n    JavaOptions,\n    JavaConfig,\n    ClassConfiguration,\n} from '../native';\nimport {\n    JavaClass,\n    JavaClassConstructorType,\n    JavaVersion,\n    UnknownJavaClass,\n    UnknownJavaClassType,\n} from './definitions';\nimport { getJavaLibPath, getNativeLibPath } from './nativeLib';\n\nexport { clearDaemonProxies, clearClassProxies, logging } from '../native';\n\n/**\n * The static java instance\n */\nlet javaInstance: Java | null = null;\n\n/**\n * Options for creating the Java VM.\n */\nexport interface JVMOptions extends JavaOptions {\n    /***\n     * The path to the native library\n     */\n    libPath?: string | null;\n    /**\n     * The version of the jvm to request\n     */\n    version?: string | JavaVersion | null;\n    /**\n     * Additional arguments to pass to the JVM\n     */\n    opts?: Array<string> | null;\n    /**\n     * Whether this runs inside a packaged electron app\n     */\n    isPackagedElectron?: boolean;\n}\n\n/**\n * Ensure the java vm is created.\n * If the jvm is already created, this does nothing.\n * If the vm is not created yet, the jvm will be created upon this call.\n * This method is also called every time with no arguments when any call\n * to the jvm is done in another method.\n *\n * ## Examples\n * Specify the path to jvm.(dylib|dll|so) manually,\n * specify the java version to use and set to use daemon threads.\n * ```ts\n * import { ensureJvm, JavaVersion } from 'java-bridge';\n *\n * ensureJvm({\n *     libPath: 'path/to/jvm.dll',\n *     version: JavaVersion.VER_9,\n * });\n * ```\n *\n * Let the plugin find the jvm.(dylib|dll|so)\n * ```ts\n * ensureJvm({\n *     version: JavaVersion.VER_9,\n * });\n * ```\n *\n * Let the plugin find the jvm.(dylib|dll|so) and use the default options\n * ```ts\n * ensureJvm();\n * ```\n *\n * ## Notes on the `classpath` option\n *\n * If you need to set the class path *before* jvm startup, for example\n * when using libraries with custom class loaders, you'd need to call\n * `ensureJvm` *before* making any other call to `java-bridge` as those\n * methods may themselves call `ensureJvm` with no arguments\n * (see comment above). Altering the startup classpath after jvm boot is\n * not possible, you can only alter the runtime classpath using\n * `appendClasspath` or `appendClasspathAny` which may not reflect\n * in an altered classpath in your java application/library if your\n * application is using a custom classpath (e.g. Spring Boot).\n *\n * Also, it is not possible to restart the jvm after is has been started\n * once, in order to alter the startup classpath. This is due to some\n * limitations with the destructor feature of the node.js native api,\n * which may not call the destructor in time and having two jvm instances\n * in the same application is not allowed by java. Additionally, destroying\n * the jvm instance may cause *undefined behaviour*, which may or may not\n * cause the application to crash. Let's not do that.\n *\n * @param options the options to use when creating the jvm\n * @return true if the jvm was created and false if the jvm already existed and was not created\n */\nexport function ensureJvm(options?: JVMOptions): boolean {\n    if (!javaInstance) {\n        javaInstance = new Java(\n            options?.libPath,\n            options?.version,\n            options?.opts,\n            options,\n            getJavaLibPath(),\n            getNativeLibPath(options?.isPackagedElectron ?? false)\n        );\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Get the addon's internal class loader.\n * This may be used in combination with {@link setClassLoader}\n * to create a custom class loader and load classes from it.\n *\n * ## Example\n * ```ts\n * import { getClassLoader, setClassLoader, importClass } from 'java-bridge';\n *\n * const classLoader = getClassLoader();\n *\n * const URLClassLoader = importClass('java.net.URLClassLoader');\n * const URL = importClass('java.net.URL');\n *\n * // This actually happens internally when appendClasspath is called\n * const newClassLoader = new URLClassLoader([new URL('file:///path/to/my.jar')], classLoader);\n *\n * setClassLoader(newClassLoader);\n * ```\n */\nexport function getClassLoader(): UnknownJavaClass {\n    ensureJvm();\n    return javaInstance!.classLoader as UnknownJavaClass;\n}\n\n/**\n * Set the internal class loader to use.\n * This allows you to create a custom class loader\n * and import classes using {@link importClass} or {@link importClassAsync}.\n * Without setting the custom class loader, the default class loader will be used.\n *\n * @param classLoader the new class loader to use\n */\nexport function setClassLoader(classLoader: UnknownJavaClass): void {\n    ensureJvm();\n    javaInstance!.classLoader = classLoader;\n}\n\n/**\n * Import a class.\n * Returns the constructor of the class to be created.\n * For example, import \"java.util.ArrayList\" for a java Array List.\n *\n * Define a custom class type for the imported class and pass the\n * constructor type of the class as the template parameter to get\n * the proper type returned. You could also just cast the result.\n *\n * When passing a {@link ClassConfiguration} object, the config will be applied\n * to this class. This config does not apply to any other class.\n * If you want to change the config for all classes, use the\n * {@link config} class in order to do that. Any undefined field\n * in the config will be ignored and the default value will be used.\n * If you want to change the sync and async suffixes to an empty string,\n * you can pass an empty string as the suffix.\n *\n * ## Examples\n * ### Import ``java.util.ArrayList`` and create a new instance of it\n * ```ts\n * import { importClass } from 'java-bridge';\n *\n * // Import java.util.ArrayList\n * const ArrayList = importClass('java.util.ArrayList');\n *\n * // Create a new instance of ArrayList\n * const list = new ArrayList();\n * ```\n *\n * ### Import ``java.util.ArrayList`` with types\n * ```ts\n * import { importClass, JavaClass, JavaType } from 'java-bridge';\n *\n * // Definitions for class java.util.List\n * declare class List<T extends JavaType> extends JavaClass {\n *     size(): Promise<number>;\n *     sizeSync(): number;\n *     add(e: T): Promise<void>;\n *     addSync(e: T): void;\n *     get(index: number): Promise<T>;\n *     getSync(index: number): T;\n *     toArray(): Promise<T[]>;\n *     toArraySync(): T[];\n *     isEmpty(): Promise<boolean>;\n *     isEmptySync(): boolean;\n * }\n *\n * // Definitions for class java.util.ArrayList\n * declare class ArrayListClass<T extends JavaType> extends List<T> {\n *     public constructor(other: ArrayListClass<T>);\n *     public constructor();\n * }\n *\n * // This causes the class to be imported when the module is loaded.\n * class ArrayList<T> extends importClass<typeof ArrayListClass>('java.util.ArrayList')<T> {}\n *\n * // Create a new ArrayList instance\n * const list = new ArrayList<string>();\n *\n * // Add some contents to the list\n * list.add('Hello');\n * list.add('World');\n *\n * // Check the list contents\n * assert.equals(list.sizeSync(), 2);\n * assert.equals(list.getSync(0), 'Hello');\n * assert.equals(list.getSync(1), 'World');\n * ```\n *\n * ### Import ``java.util.ArrayList`` with custom config\n * ```ts\n * import { importClass, config } from 'java-bridge';\n *\n * // Import java.util.ArrayList with custom config\n * const ArrayList = importClass('java.util.ArrayList', {\n *    syncSuffix: '',\n *    asyncSuffix: 'Async',\n * });\n *\n * // Create a new instance of ArrayList\n * const list = new ArrayList();\n *\n * // Call the async method\n * await list.addAsync('Hello World!');\n *\n * // Call the sync method\n * list.add('Hello World!');\n * ```\n *\n * @template T the type of the java class to import as a js type\n * @param classname the name of the class to resolve\n * @param config the config to use when importing the class\n * @return the java class constructor\n */\nexport function importClass<\n    T extends JavaClassConstructorType = UnknownJavaClassType,\n>(classname: string, config?: ClassConfiguration): T {\n    ensureJvm();\n    return javaInstance!.importClass(classname, config) as T;\n}\n\n/**\n * @inheritDoc importClass\n */\nexport function importClassAsync<\n    T extends JavaClassConstructorType = UnknownJavaClassType,\n>(classname: string, config?: ClassConfiguration): Promise<T> {\n    ensureJvm();\n    return javaInstance!.importClassAsync(classname, config) as Promise<T>;\n}\n\n/**\n * Append a single or multiple jars to the class path.\n *\n * Just replaces the old internal class loader with a new one containing the new jars.\n * This doesn't check if the jars are valid and/or even exist.\n * The new classpath will be available to all classes imported after this call.\n *\n * If you want to import whole directories, you can use glob patterns.\n *\n * ## Example\n * ### Append single files\n * ```ts\n * import { appendClasspath } from 'java-bridge';\n *\n * // Append a single jar to the class path\n * appendClasspath('/path/to/jar.jar');\n *\n * // Append multiple jars to the class path\n * appendClasspath(['/path/to/jar1.jar', '/path/to/jar2.jar']);\n * ```\n * or\n * ```ts\n * import { classpath } from 'java-bridge';\n *\n * // Append a single jar to the class path\n * classpath.append('/path/to/jar.jar');\n * ```\n *\n * ### Append a directory to the class path\n * ```ts\n * import { appendClasspath } from 'java-bridge';\n *\n * // Append a directory to the class path\n * appendClasspath('/path/to/dir/*');\n * // Append just the jar files in the directory\n * appendClasspath('/path/to/dir/*.jar');\n * ```\n *\n * @param path the path(s) to add\n */\nexport function appendClasspath(path: string | string[]): void {\n    ensureJvm();\n    javaInstance!.appendClasspath(path);\n}\n\n/**\n * Instantly delete a java object and allow the object\n * to be garbage collected by the java gc.\n * Calling this method on an object that has already been\n * deleted will throw an error. If an object has been deleted,\n * it is not possible to use it anymore, although the object\n * may still exist in the javascript process.\n *\n * **NOTE:** Use this method with caution, as there is no proper\n * synchronization with deleting the object and other methods using\n * this object in an asynchronous manner. This may cause the object\n * to be deleted while another method is still using it.\n * This may cause the program to crash in very rare cases.\n *\n * @param obj the object to delete\n */\nexport function deleteObject(obj: JavaClass): void {\n    ensureJvm();\n    javaInstance!.delete(obj);\n}\n\n/**\n * Check if `this_obj` is instance of `other`.\n * This uses the native java `instanceof` operator.\n * You may want to use this if {@link JavaClass.instanceOf}\n * is overridden, as that method itself does not override\n * any method defined in the specific java class named 'instanceOf'.\n *\n * ## Example\n * ```ts\n * import { instanceOf, importClass } from 'java-bridge';\n *\n * const ArrayList = importClass('java.util.ArrayList');\n * const list = new ArrayList();\n *\n * isInstanceOf(list, ArrayList); // true\n * isInstanceOf(list, 'java.util.ArrayList'); // true\n * isInstanceOf(list, 'java.util.List'); // true\n * isInstanceOf(list, 'java.util.Collection'); // true\n * isInstanceOf(list, 'java.lang.Object'); // true\n * isInstanceOf(list, 'java.lang.String'); // false\n *\n * // You can also use the instanceOf method (if not overridden)\n * list.instanceOf(ArrayList); // true\n * list.instanceOf('java.util.ArrayList'); // true\n * list.instanceOf('java.util.List'); // true\n * list.instanceOf('java.util.Collection'); // true\n * list.instanceOf('java.lang.Object'); // true\n * list.instanceOf('java.lang.String'); // false\n * ```\n *\n * @param this_obj the object to check\n * @param other the class or class name to check against\n * @return true if `this_obj` is an instance of `other`\n */\nexport function isInstanceOf<T extends object>(\n    this_obj: JavaClass,\n    other: string | T\n): boolean {\n    ensureJvm();\n    return javaInstance!.isInstanceOf(this_obj, other);\n}\n\n/**\n * Methods for altering and querying the class path.\n * @example\n * import { classpath } from 'java-bridge';\n *\n * // Append a jar to the class path\n * classpath.append('/path/to/jar.jar');\n *\n * assert.equal(classpath.get().length, 1);\n * assert.equal(classpath.get()[0], '/path/to/jar.jar');\n */\nexport namespace classpath {\n    /**\n     * @inheritDoc appendClasspath\n     */\n    export function append(path: string | string[]): void {\n        appendClasspath(path);\n    }\n\n    /**\n     * Get the loaded files or directories in the class path\n     *\n     * @returns a list of the loaded files\n     */\n    export function get(): string[] {\n        ensureJvm();\n        return javaInstance!.loadedJars;\n    }\n}\n\n/**\n * A callback for any output redirected from stdout/stderr from the java process.\n *\n * @param err an error if the conversion of the output failed.\n *            This is null if the output was valid. This will probably never be set.\n * @param data the data that was converted. This is unset if <code>err</code> is set.\n */\nexport type StdoutCallback = (err: Error | null, data?: string) => void;\n\n/**\n * The class guarding the stdout redirect.\n * Keep this instance in scope to not lose the redirect.\n * As soon as this gets garbage collected, the redirection\n * of the stdout/stderr will be stopped. Only one instance\n * of this can exist at a time. Call {@link reset} to stop\n * redirecting the program output and release this class\n * instance early.\n *\n * This can be created by calling {@link stdout.enableRedirect}.\n *\n * ## Example\n * ```ts\n * import { stdout } from 'java-bridge';\n *\n * const guard = stdout.enableRedirect((_, data) => {\n *     console.log('Stdout:', data);\n * }, (_, data) => {\n *     console.error('Stderr:', data);\n * });\n *\n * // Change the receiver method\n * guard.on('stderr', (_, data) => {\n *     console.warn('Stderr:', data);\n * });\n *\n * // Disable a receiver\n * guard.on('stdout', null);\n *\n * // Disable stdout redirect\n * guard.reset();\n * ```\n *\n * ## See also\n * * {@link stdout.enableRedirect}\n */\nexport interface StdoutRedirectGuard {\n    /**\n     * Set the stdout/stderr event handler.\n     * Pass <code>null</code> to disable this specific handler.\n     * Only accepts 'stdout' and 'stderr' as the <code>event</code>\n     * argument. Overwrites the previous handler.\n     *\n     * @param event the event to listen on\n     * @param callback the callback\n     */\n    on(event: 'stdout' | 'stderr', callback: StdoutCallback | null): void;\n\n    /**\n     * Reset this <code>StdoutRedirectGuard</code> instance.\n     * After this call, the stdout/stderr will no longer\n     * be redirected to the specified methods and any call\n     * to this class will throw an error as this counts as destroyed.\n     */\n    reset(): void;\n}\n\n/**\n * A namespace containing methods for redirecting the stdout/stderr of the java process.\n *\n * ## See also\n * * {@link StdoutRedirectGuard}\n * * {@link stdout.enableRedirect}\n */\nexport namespace stdout {\n    /**\n     * Enable stdout/stderr redirection.\n     *\n     * Pass methods for the stdout and stderr output to be redirected to.\n     * These methods must accept an error as the first argument,\n     * although this will probably never be set and can be ignored.\n     * The second argument is the data that was redirected.\n     *\n     * Setting any method to ``null`` or ``undefined`` will disable the redirect for that method.\n     * This also allows you not set any handler which does not make any sense at all.\n     *\n     * ## Examples\n     * ### Redirect all data to the js console\n     * ```ts\n     * import { stdout } from 'java-bridge';\n     *\n     * const guard = stdout.enableRedirect((_, data) => {\n     *     console.log('Stdout:', data);\n     * }, (_, data) => {\n     *     console.error('Stderr:', data);\n     * });\n     * ```\n     *\n     * ### Redirect stdout to the js console\n     * ```ts\n     * const guard = stdout.enableRedirect((_, data) => {\n     *     console.log('Stdout:', data);\n     * });\n     * ```\n     *\n     * ### Redirect stderr to the js console\n     * ```ts\n     * const guard = stdout.enableRedirect(null, (_, data) => {\n     *    console.error('Stderr:', data);\n     * });\n     * ```\n     *\n     * ### Redirect nothing to the js console (y tho)\n     * This enables you to print nothing to nowhere.\n     * ```ts\n     * // Why would you do this?\n     * const guard = stdout.enableRedirect(null, null);\n     *\n     * // Or\n     * const guard = stdout.enableRedirect();\n     * ```\n     *\n     * @see StdoutRedirectGuard\n     * @see StdoutCallback\n     * @param stdout the callback to be called when stdout is received\n     * @param stderr the callback to be called when stderr is received\n     * @returns a <code>StdoutRedirectGuard</code> instance. Keep this instance in scope to not lose the redirect.\n     */\n    export function enableRedirect(\n        stdout?: StdoutCallback | null,\n        stderr?: StdoutCallback | null\n    ): StdoutRedirectGuard {\n        ensureJvm();\n        return javaInstance!.setStdoutCallbacks(stdout, stderr);\n    }\n}\n\n/**\n * The class for implementing java interfaces.\n * Keep this instance in scope to not destroy the java object.\n * Call {@link reset} to instantly destroy this instance.\n *\n * ## Notes\n * Keeping this instance alive may cause your process not to exit\n * early. Thus, you must wait for the javascript garbage collector\n * to destroy this instance even if you called {@link reset}.\n *\n * Once this instance has been destroyed, either by calling {@link reset}\n * or the garbage collector, any call to any method defined earlier\n * by {@link newProxy} will throw an error in the java process.\n *\n * ## Example\n * ```ts\n * import { newProxy } from 'java-bridge';\n *\n * const proxy = newProxy('path.to.MyInterface', {\n *     // Define methods...\n * });\n *\n * // Do something with the proxy\n * instance.someMethod(proxy);\n *\n * // Destroy the proxy\n * proxy.reset();\n * ```\n *\n * ## See also\n * * {@link newProxy}\n */\nexport interface JavaInterfaceProxy<T extends ProxyRecord<T> = AnyProxyRecord> {\n    /**\n     * A dummy property to make sure the type is correct.\n     * This property will never be set.\n     */\n    _dummy?: T;\n\n    /**\n     * Destroy the proxy class.\n     * After this call any call to any method defined by the\n     * interface will throw an error on the java side. This error\n     * may be thrown back to the node process, if you are not\n     * specifically implementing methods that will be called\n     * from another (java) thread.\n     * Throws an error if the proxy has already been destroyed.\n     *\n     * @param force whether to force the destruction of the proxy\n     * if it should be kept alive as a daemon\n     */\n    reset(force?: boolean): void;\n}\n\n/**\n * An interface proxy method.\n * Any arguments passed to this method are values converted from java values.\n * The return value will be converted back to a java type.\n *\n * @param args the arguments passed from the java process\n * @return the value to pass back to the java process\n */\nexport type ProxyMethod = (...args: any[]) => any;\ntype InternalProxyRecord = Parameters<\n    typeof Java.prototype.createInterfaceProxy\n>[1];\n\n/**\n * A record of methods to implement.\n * Useful for creating a proxy for a specific interface.\n */\nexport type ProxyRecord<T> = Partial<Record<keyof T, ProxyMethod>>;\n\n/**\n * A generic proxy record.\n */\nexport type AnyProxyRecord = Record<string, ProxyMethod>;\n\n/**\n * Create a new java interface proxy.\n * This allows you to implement java interfaces in javascript.\n *\n * Pass an object as the second argument with the names of the\n * methods you want to implement as keys and the implementations\n * as values in order to expose these methods to the java process.\n * Any arguments will be converted to javascript values and\n * return values will be converted to java values.\n *\n * When the java process tries to call any method which is\n * not implemented by the proxy, an error will be thrown.\n *\n * ## Examples\n * ### Implement ``java.lang.Runnable``\n * ```ts\n * import { newProxy, importClass } from 'java-bridge';\n *\n * // Define the interface\n * const runnable = newProxy('java.lang.Runnable', {\n *     run: (): void => {\n *         console.log('Hello World!');\n *     }\n * });\n *\n * // Note: You can't do something like this:\n * // runnable.run();\n *\n * // Pass the proxy to a java method instead:\n * const Thread = importClass('java.lang.Thread');\n * const thread = new Thread(runnable); // <- Pass the proxy here\n *\n * // NOTE: You don't have to call this asynchronously\n * // as this call instantly returns.\n * thread.startSync();\n * ```\n *\n * ### Implement ``java.util.function.Function`` to transform a string\n * ```ts\n * const func = newProxy('java.util.function.Function', {\n *     // Any parameters and return types will be automatically converted\n *     apply: (str: string): string => {\n *         return str.toUpperCase();\n *     }\n * });\n *\n * // Import the string class\n * const JString = java.importClass('java.lang.String');\n * const str = new JString('hello');\n *\n * // Pass the proxy.\n * // NOTE: You must call this method async otherwise your program will hang.\n * // See notes for more info.\n * const transformed = await str.transform(func);\n *\n * assert.assertEquals(transformed, 'HELLO');\n * ```\n *\n * Which is equivalent to the following java code:\n * ```java\n * Function<String, String> func = new Function<>() {\n *     @Override\n *     public String apply(String str) {\n *         return str.toUpperCase();\n *     }\n * };\n *\n * String str = \"hello\";\n * String transformed = str.transform(func);\n * assert.assertEquals(transformed, \"HELLO\");\n * ```\n *\n * #### Throwing exceptions\n * Any exceptions thrown by the proxy will be converted to java exceptions\n * and then rethrown in the java process. This may cause the exception\n * to again be rethrown in the javascript process.\n * ```ts\n * const func = newProxy('java.util.function.Function', {\n *     apply: (str: string): string => {\n *         throw new Error('Something went wrong');\n *     }\n * });\n *\n * const JString = java.importClass('java.lang.String');\n * const str = new JString('hello');\n *\n * // This will re-throw the above error\n * const transformed: never = await str.transform(func);\n * ```\n *\n * ## Notes\n * * Keep this instance in scope to not destroy the interface proxy.\n * * Call {@link JavaInterfaceProxy.reset} to instantly destroy this instance.\n *   Please note that calling {@link JavaInterfaceProxy.reset} is not necessary,\n *   the proxy instance will be automatically destroyed when it is garbage collected.\n *   Calling {@link JavaInterfaceProxy.reset} will just speed up the process.\n * * If any method is queried by the java process and not implemented in here,\n *   an exception will be thrown in the java process.\n * * Any errors thrown in the javascript process will be rethrown in the java process.\n *\n * ### Possible deadlock warning\n * When calling a java method that uses an interface defined by this, you must call\n * that method using the interface asynchronously as Node.js is single threaded\n * and can't wait for the java method to return while calling the proxy method at the\n * same time.\n *\n * If you still want to call everything in a synchronous manner, make sure to enable\n * running the event loop while waiting for a java method to return by setting\n * {@link JavaConfig.runEventLoopWhenInterfaceProxyIsActive} to true.\n * **This may cause application crashes, so it is strongly recommended to just use async methods.**\n *\n * ### Keeping the proxy alive\n * If you want to keep the proxy alive, you must keep this instance in scope.\n * If that is not an option for you, you can manually keep the proxy alive\n * by setting the {@link InterfaceProxyOptions}.keepAsDaemon option to true.\n *\n * ```ts\n * const proxy = newProxy('java.lang.Runnable', {\n *    run: (): void => {\n *      console.log('Hello World!');\n *    }\n * }, {\n *    keepAsDaemon: true\n * });\n *\n * const TimeUnit = java.importClass('java.util.concurrent.TimeUnit');\n * const ScheduledThreadPoolExecutor = java.importClass(\n *     'java.util.concurrent.ScheduledThreadPoolExecutor'\n * );\n * const executor = new ScheduledThreadPoolExecutor(1);\n *\n * // 'proxy' will eventually be garbage collected,\n * // but it will be kept alive due to this option.\n * executor.scheduleAtFixedRateSync(proxy, 0, 1, TimeUnit.SECONDS);\n * ```\n *\n * This will keep the proxy alive internally, thus the instance can be moved\n * out of scope. However, this will also keep the JVM alive, so you should\n * only use this if you are sure that you want to keep the JVM alive.\n *\n * If you want to destroy the proxy, you must call {@link clearDaemonProxies}.\n * This will destroy all proxies which are kept alive by this option.\n * Calling {@link JavaInterfaceProxy.reset} will not destroy a proxy\n * kept alive by this option unless the force option is set to true.\n *\n * ## See also\n * * {@link JavaInterfaceProxy}\n * * {@link InterfaceProxyOptions}\n *\n * @param interfaceName the name of the java interface to implement\n * @param methods the methods to implement.\n * @param opts the options to use\n * @returns a proxy class to pass back to the java process\n */\nexport function newProxy<T extends ProxyRecord<T> = AnyProxyRecord>(\n    interfaceName: string,\n    methods: T,\n    opts?: InterfaceProxyOptions\n): JavaInterfaceProxy<T> {\n    ensureJvm();\n    const proxyMethods: InternalProxyRecord = Object.create(null);\n\n    for (const [name, method] of Object.entries(methods)) {\n        proxyMethods[name] = (\n            err: null | Error,\n            callback: (err: Error | null, data?: any | null) => void,\n            ...args: any[]\n        ): void => {\n            if (err) {\n                // This is extremely unlikely to happen.\n                // Probably out of memory or something.\n                throw err;\n            }\n\n            try {\n                const res = (method as ProxyMethod)(...args);\n                if (res instanceof Promise) {\n                    res.then(\n                        (res: unknown) => callback(null, res),\n                        (e: unknown) => {\n                            if (e instanceof Error) {\n                                callback(e);\n                            } else {\n                                callback(new Error(String(e)));\n                            }\n                        }\n                    );\n                } else {\n                    callback(null, res);\n                }\n            } catch (e: unknown) {\n                if (e instanceof Error) {\n                    callback(e);\n                } else {\n                    callback(new Error(String(e)));\n                }\n            }\n        };\n    }\n\n    return javaInstance!.createInterfaceProxy(\n        interfaceName,\n        proxyMethods,\n        opts\n    ) as JavaInterfaceProxy<T>;\n}\n\n/**\n * Get the static java instance.\n * This has no real use, all important methods are exported explicitly.\n */\nexport function getJavaInstance(): Java | null {\n    return javaInstance;\n}\n\n/**\n * @inheritDoc JavaConfig\n */\nexport const config = new JavaConfig();\n","import path from 'path';\nimport fs, { readFileSync } from 'fs';\n\nconst { platform, arch } = process;\n\nconst APP_ASAR_REGEX = /([\\\\/])app\\.asar([\\\\/])/gim;\nconst APP_ASAR_UNPACKED = '$1app.asar.unpacked$2';\n\nfunction getModule(base: string, isPackagedElectron: boolean): string {\n    const local = path.join(__dirname, base + '.node');\n\n    if (fs.existsSync(local)) {\n        if (isPackagedElectron) {\n            console.warn('Using local native module in packaged Electron app');\n        }\n\n        return local;\n    } else {\n        const module = base.replaceAll('.', '-').replace('java', 'java-bridge');\n\n        let res: string;\n        if (__non_webpack_require__ && __non_webpack_require__.resolve) {\n            res = __non_webpack_require__.resolve(module);\n        } else {\n            res = require.resolve(module);\n        }\n\n        if (isPackagedElectron)\n            res = res.replace(APP_ASAR_REGEX, APP_ASAR_UNPACKED);\n        return res;\n    }\n}\n\nfunction UnsupportedPlatform(): Error {\n    return new Error(`Unsupported platform: ${platform} ${arch}`);\n}\n\nfunction isMusl() {\n    // For Node 10\n    if (!process.report || typeof process.report.getReport !== 'function') {\n        try {\n            return readFileSync('/usr/bin/ldd', 'utf8').includes('musl');\n        } catch (e) {\n            return true;\n        }\n    } else {\n        const { glibcVersionRuntime } = (process.report.getReport() as any)\n            .header;\n        return !glibcVersionRuntime;\n    }\n}\n\nexport function getNativeLibPath(isPackagedElectron: boolean): string {\n    switch (platform) {\n        case 'android':\n            switch (arch) {\n                case 'arm64':\n                    return getModule('java.android-arm64', isPackagedElectron);\n                case 'arm':\n                    return getModule(\n                        'java.android-arm-eabi',\n                        isPackagedElectron\n                    );\n                default:\n                    throw UnsupportedPlatform();\n            }\n        case 'win32':\n            return getModule(`java.win32-${arch}-msvc`, isPackagedElectron);\n        case 'darwin':\n            return getModule(`java.darwin-${arch}`, isPackagedElectron);\n        case 'freebsd':\n            return getModule(`java.freebsd-${arch}`, isPackagedElectron);\n        case 'linux':\n            switch (arch) {\n                case 'x64':\n                case 'arm64':\n                    return getModule(\n                        `java.linux-${arch}-${isMusl() ? 'musl' : 'gnu'}`,\n                        isPackagedElectron\n                    );\n                case 'arm':\n                    return getModule(\n                        'java.linux-arm-gnueabihf',\n                        isPackagedElectron\n                    );\n                default:\n                    throw UnsupportedPlatform();\n            }\n        default:\n            throw UnsupportedPlatform();\n    }\n}\n\nexport function getJavaLibPath(): string {\n    const lib = path.join(__dirname, 'JavaBridge.jar');\n\n    if (fs.existsSync(lib) && fs.statSync(lib).isFile()) {\n        return lib;\n    } else {\n        throw new Error('JavaBridge.jar not found');\n    }\n}\n","import { importClass, importClassAsync } from './java';\n\n/**\n * Get the version of the Java VM in use.\n * Async version.\n *\n * @see getJavaVersionSync\n * @returns the java version string\n */\nexport async function getJavaVersion(): Promise<string> {\n    const system = await importClassAsync('java.lang.System');\n    return await system.getProperty('java.version');\n}\n\n/**\n * Get the version of the Java VM in use.\n * Sync version.\n *\n * This is equal to the following java implementation:\n * ```java\n * public static String getJavaVersion() {\n *     return System.getProperty(\"java.version\");\n * }\n * ```\n *\n * @see getJavaVersion\n * @returns the java version string\n */\nexport function getJavaVersionSync(): string {\n    const system = importClass('java.lang.System');\n    return system.getPropertySync('java.version');\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 973;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"\";","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(772);\n"],"names":["root","factory","exports","module","define","amd","global","process","dlopen","__dirname","error","Error","existsSync","readFileSync","join","platform","arch","nativeBinding","localFileExisted","loadError","isMusl","report","getReport","glibcVersionRuntime","header","lddPath","toString","trim","includes","e","JavaInterfaceProxy","clearDaemonProxies","Java","clearClassProxies","JavaConfig","StdoutRedirect","getJavaLibPath","logging","JavaVersion","Object","freeze","JavaObject","JavaClassInstance","JavaClassProxy","JavaClass","JavaClassConstructor","UnknownJavaClass","JavaError","JavaThrowable","java","get","getJavaVersion","getJavaVersionSync","ensureJvm","javaInstance","classLoader","classname","config","importClass","importClassAsync","obj","delete","this_obj","other","isInstanceOf","interfaceName","methods","opts","proxyMethods","create","name","method","entries","err","callback","args","res","Promise","then","String","createInterfaceProxy","options","libPath","version","getNativeLibPath","isPackagedElectron","appendClasspath","path","classpath","stdout","append","loadedJars","enableRedirect","stderr","setStdoutCallbacks","getModule","UnsupportedPlatform","lib","statSync","isFile","APP_ASAR_REGEX","APP_ASAR_UNPACKED","base","local","console","warn","replaceAll","replace","resolve","async","system","getProperty","getPropertySync","webpackEmptyContext","req","code","keys","id","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","loaded","__webpack_modules__","call","o","prop","prototype","hasOwnProperty","nmd","paths","children","p"],"sourceRoot":""}
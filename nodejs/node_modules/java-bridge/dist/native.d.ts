/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Configuration for the Java class proxy.
 *
 * @since 2.4.0
 */
export interface ClassConfiguration {
  /**
   * If true, the event loop will be run when an interface proxy is active.
   * If not specified, the value from the global configuration will be used.
   */
  runEventLoopWhenInterfaceProxyIsActive?: boolean
  /**
   * If true, the custom inspect method will be used to display the object in the console.
   * If not specified, the value from the global configuration will be used.
   */
  customInspect?: boolean
  /**
   * The suffix to use for synchronous methods.
   * Set this value to an empty string to disable the suffix.
   * The default value is "Sync".
   * Setting this value to the same value as asyncSuffix will result in an error.
   * If not specified, the value from the global configuration will be used.
   */
  syncSuffix?: string
  /**
   * The suffix to use for asynchronous methods.
   * Set this value to an empty string to disable the suffix.
   * The default value is an empty string.
   * Setting this value to the same value as syncSuffix will result in an error.
   * If not specified, the value from the global configuration will be used.
   */
  asyncSuffix?: string
  /**
   * If true, any Java exception will be returned in the `cause`
   * field of the thrown `JavaError` even in async methods.
   * Enabling this will cause the stack trace of the
   * JavaScript error to be lost.
   * If not specified, the value from the global configuration will be used.
   *
   * @since 2.6.0
   */
  asyncJavaExceptionObjects?: boolean
}
/**
 * Configuration for the Java class proxy.
 *
 * @since 2.4.0
 */
export interface Config {
  /**
   * If true, the event loop will be run when an interface proxy is active.
   *
   * @since 2.2.3
   */
  runEventLoopWhenInterfaceProxyIsActive: boolean
  /**
   * If true, the custom inspect method will be used to display the object in the console.
   *
   * @since 2.4.0
   */
  customInspect: boolean
  /**
   * The suffix to use for synchronous methods.
   * Set this value to an empty string to disable the suffix.
   * The default value is "Sync".
   * Setting this value to the same value as asyncSuffix will result in an error.
   *
   * @since 2.4.0
   */
  syncSuffix?: string
  /**
   * The suffix to use for asynchronous methods.
   * Set this value to an empty string to disable the suffix.
   * The default value is an empty string.
   * Setting this value to the same value as syncSuffix will result in an error.
   *
   * @since 2.4.0
   */
  asyncSuffix?: string
  /**
   * If true, any Java exception will be returned in the `cause`
   * field of the thrown `JavaError` even in async methods.
   * Enabling this will cause the stack trace of the
   * JavaScript error to be lost.
   * Default is false.
   *
   * @since 2.6.0
   */
  asyncJavaExceptionObjects?: boolean
}
/** Options for the interface proxies */
export interface InterfaceProxyOptions {
  /**
   * If true, the proxy will be kept as a daemon
   * proxy after the interface has been destroyed
   */
  keepAsDaemon?: boolean
}
/** Clears the list of daemon proxies. */
export declare function clearDaemonProxies(): void
/**
 * Clear the class proxy cache.
 * Use this method in order to reset the config for all class proxies.
 * The new config will be applied once the class is imported again.
 *
 * @since 2.4.0
 */
export declare function clearClassProxies(): void
/**
 * Options for the Java VM.
 * Not the same as vm arguments.
 */
export interface JavaOptions {
  /**
   * Additional items to add to the class path. This does allow for wildcard imports
   * using glob patterns. If a path is unreadable, an error will be thrown.
   * This behaviour can be changed by setting `ignore_unreadable_class_path_entries` to true.
   */
  classpath?: Array<string>
  /** Whether to ignore unreadable class path entries */
  ignoreUnreadableClassPathEntries?: boolean
}
/**
 * Get the path to the jvm.(dll|so|dylib) file.
 * Throws an error if the library could not be found.
 */
export declare function getJavaLibPath(): string
export declare class JavaInterfaceProxy {
  get proxy(): object | null
  reset(force?: boolean | undefined | null): void
}
/**
 * The main java class.
 * This should only be created once per process.
 * Any other attempts to create a new jvm instance will fail.
 */
export declare class Java {
  /**
   * Create a new JVM instance.
   * @param libPath The path to jvm.(dll|so|dylib)
   * @param version The JVM version to use.
   * @param opts The JVM options to use.
   */
  constructor(libPath: string | undefined | null, version: string | undefined | null, opts: Array<string> | undefined | null, javaOptions: JavaOptions | undefined | null, javaLibPath: string, nativeLibPath: string)
  /**
   * Import a java class
   * Will import the class and parse all of its methods and fields.
   * The imported class will be cached for future use.
   */
  importClass(className: string, config?: ClassConfiguration | undefined | null): object
  /**
   * Import a java class (async)
   * Will return a promise that resolves to the class instance.
   *
   * If the underlying Java throwable should be contained in the error object,
   * set `asyncJavaExceptionObjects` to `true`. This will cause the JavaScript
   * stack trace to be lost. Setting this option in the global config will
   * **not** affect this method, this option has to be set each time this
   * method is called.
   *
   * @see importClass
   */
  importClassAsync(className: string, config?: ClassConfiguration | undefined | null): Promise<object>
  /**
   * Get the wanted JVM version.
   * This may not match the actual JVM version.
   */
  get wantedVersion(): string
  /**
   * Get the actual JVM version.
   * This may not match the wanted JVM version.
   */
  get version(): string
  /** Get the loaded jars. */
  get loadedJars(): Array<string>
  /** Append a single or multiple jars to the classpath. */
  appendClasspath(classpath: string | string[]): void
  /** Set the stdout/stderr callbacks */
  setStdoutCallbacks(stdoutCallback?: ((err: Error | null, data?: string) => void) | undefined | null, stderrCallback?: ((err: Error | null, data?: string) => void) | undefined | null): StdoutRedirect
  createInterfaceProxy(classname: string, methods: Record<string, (err: null | Error, callback: (err: Error | null, data?: any | null) => void, ...args: any[]) => void>, options?: InterfaceProxyOptions | undefined | null): JavaInterfaceProxy
  /** Check if `this` is instance of `other` */
  isInstanceOf(thisObj: object, other: string | object): boolean
  get classLoader(): object
  set classLoader(classLoader: object)
  delete(obj: object): void
}
/**
 * Configuration options for the java bridge.
 *
 * As of version 2.4.0, the options are cached inside the class proxy cache.
 * This means that changing the options will not affect any class proxies
 * that have already been created by importing a class using {@link importClass}
 * or {@link importClassAsync}. You must clear the class proxy cache using the
 * {@link clearClassProxies} method in order to apply the new options to all
 * classes imported at a later date. This does not affect already instantiated
 * or imported classes.
 *
 * Do not instantiate this class. Use the {@link default.config} instance instead.
 *
 * @since 2.2.3
 */
export declare class JavaConfig {
  /**
   * Do not instantiate this class.
   * Use the {@link default.config} instance instead.
   */
  constructor()
  /**
   * **Experimental Feature**
   *
   * Set whether to run the event loop when an interface proxy is active.
   * This is disabled by default. Enabling this will cause the bridge
   * to run the event loop when an interface proxy either as direct
   * proxy or as daemon proxy is active. This is only required if the
   * proxied method calls back into the javascript process in the same thread.
   * If the proxy is used either in an async method or in a different thread,
   * this is not required.
   *
   * **Note:** Enabling this may cause the application to crash. Use with caution.
   *
   * @since 2.2.3
   * @experimental
   * @param value whether to run the event loop when an interface proxy is active
   */
  set runEventLoopWhenInterfaceProxyIsActive(value: boolean)
  /**
   * **Experimental Feature**
   *
   * Get whether to run the event loop when an interface proxy is active.
   * @since 2.2.3
   * @experimental
   */
  get runEventLoopWhenInterfaceProxyIsActive(): boolean
  /**
   * Whether to add custom inspect methods to java objects.
   * This is disabled by default.
   * This allows console.log to print java objects in a more readable way
   * using the `toString` method of the java object.
   *
   * @since 2.4.0
   * @param value whether to add custom inspect methods to java objects
   */
  set customInspect(value: boolean)
  /**
   * Get whether to add custom inspect methods to java objects.
   *
   * @since 2.4.0
   * @returns whether to add custom inspect methods to java objects
   */
  get customInspect(): boolean
  /**
   * Set the suffix for synchronous methods.
   * This is `Sync` by default.
   * Pass `null` or an empty string to disable the suffix.
   * This must not be the same as the {@link asyncSuffix}.
   *
   * This option does not affect standard methods of java classes
   * like `toString`, `toStringSync`, `toStringAsync` and `newInstanceAsync`.
   *
   * ## Example
   * ```ts
   * import { config, clearClassProxies } from 'java-bridge';
   *
   * // Set the async suffix in order to prevent errors
   * config.asyncSuffix = 'Async';
   * // Set the sync suffix to an empty string
   * config.syncSuffix = '';
   * // This would do the same
   * config.syncSuffix = null;
   *
   * // Clear the class proxy cache
   * clearClassProxies();
   *
   * // Import the class
   * const ArrayList = importClass('java.util.ArrayList');
   *
   * // Create a new instance
   * const list = new ArrayList();
   *
   * // Call the method
   * list.add('Hello World!');
   *
   * // Async methods now have the 'Async' suffix
   * await list.addAsync('Hello World!');
   * ```
   *
   * @see asyncSuffix
   * @since 2.4.0
   * @param value the suffix to use for synchronous methods
   */
  set syncSuffix(value: string | undefined | null)
  /**
   * Get the suffix for synchronous methods.
   *
   * @since 2.4.0
   */
  get syncSuffix(): string | null
  /**
   * Set the suffix for asynchronous methods.
   * This is `Async` by default.
   * Pass `null` or an empty string to disable the suffix.
   * This must not be the same as the {@link syncSuffix}.
   *
   * This option does not affect standard methods of java classes
   * like `toString`, `toStringSync`, `toStringAsync` and `newInstanceAsync`.
   *
   * @see syncSuffix
   * @since 2.4.0
   * @param value the suffix to use for asynchronous methods
   */
  set asyncSuffix(value: string | undefined | null)
  /**
   * Get the suffix for asynchronous methods.
   *
   * @since 2.4.0
   */
  get asyncSuffix(): string | null
  /**
   * Get whether to return Java exceptions as objects in async methods.
   *
   * @since 2.6.0
   */
  get asyncJavaExceptionObjects(): boolean | null
  /**
   * If true, any Java exception will be returned in the `cause`
   * field of the thrown `JavaError` even in async methods.
   * Enabling this will cause the stack trace of the
   * JavaScript error to be lost.
   * If not specified, the value from the global configuration will be used.
   *
   * @since 2.6.0
   */
  set asyncJavaExceptionObjects(value: boolean | undefined | null)
  /**
   * Override the whole config.
   * If you want to change only a single field, use the static setters instead.
   *
   * @since 2.4.0
   * @param value the config to use
   */
  set config(value: Config)
  /**
   * Get the current config.
   *
   * @since 2.4.0
   */
  get config(): Config
  /**
   * Reset the config to the default values.
   *
   * @since 2.4.0
   */
  reset(): void
}
export declare class StdoutRedirect {
  on(event: string, callback?: ((...args: any[]) => any) | null): void
  reset(): void
}
export declare namespace logging {
  /**
   * This method is not supported in this build.
   * It will print a warning to stderr when called.
   *
   * Re-compile the native module with the `log` feature to enable logging.
   */
  export function setLogCallbacks(out: ((data: string | null) => void) | null | undefined, err: ((data: string | null) => void) | null | undefined): void
  /**
   * This method is not supported in this build.
   * It will print a warning to stderr when called.
   *
   * Re-compile the native module with the `log` feature to enable logging.
   */
  export function initLogger(path: string): void
  /**
   * This method is not supported in this build.
   * It will print a warning to stderr when called.
   *
   * Re-compile the native module with the `log` feature to enable logging.
   */
  export function resetLogCallbacks(): void
  /**
   * Whether logging is supported.
   * Logging is disabled by default.
   * This constant currently is set to `false`
   * as logging is not supported in this build.
   */
  export const LOGGING_SUPPORTED: boolean
}
